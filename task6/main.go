package main

// Реализовать все возможные способы остановки выполнения горутины.

import (
	"context"
	"fmt"
)

// Способ 1
// Как только горутина возвращает значение, она прекращает свою работу
func Stop1() {
	return
}

// Способ 2
// Использование канала для остановки работы
// Работа горутины будет приостановлена, до момента пока на канал
// не поступят данные для чтения

func Stop2() {
	var ch chan struct{}
	ch <- struct{}{}
}

// Способ 3
// Использование контекста
// Можно создать контекст с таймаутом или использовать контекст, 
// который уже указывает на завершение.

func Stop3(ctx context.Context) {
    for {
        select {
        case <-ctx.Done(): // Если ctx сообщает о завершении, горутина останавливается
            return
        default:
        }
    }
}

func Stop4() {
	_, cancel := context.WithCancel(context.Background())
	
	//при вызове cancel горутина останавливается
	cancel()
}

// Способ 4
// Паника для екстренного завершения, 
// но с возможностью востановления, через механизм defer

func Stop5() {
	defer func() {
        if err := recover(); err != nil {
            fmt.Printf("Паника остановлена: %v\n", err)
        }
    }()
	panic("Программа завершилась с паникой")
}

func main() {}
